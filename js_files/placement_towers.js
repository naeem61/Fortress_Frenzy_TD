tiledMapData_map1 = [
  2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927,
  0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 2927, 0,
  0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0,
  0, 0, 0, 2927, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0,
  2927, 0, 2927, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0,
  2927, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0,
  2927, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0, 2927, 0, 0,
  0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0,
  0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0, 2927, 0, 0, 0, 0, 2927,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 2927, 0, 2927, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 2927, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0,
  2927, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927,
  0, 2927, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0,
  0, 0, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0,
  0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 0, 0,
  0, 0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0, 0,
  2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 0, 0, 0,
  0, 2927, 0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 2927,
  0, 0, 0, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2927, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927,
  0, 2927, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 2927, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 2927, 0,
  2927, 0, 0, 0, 0, 0, 0, 2927, 0, 2927, 0, 0, 2927, 0, 0, 2927, 0, 2927, 0,
  2927, 0, 0, 0, 0, 2927, 0, 2927, 0, 2927, 0, 2927, 0, 0, 0, 0, 0,
];

tiledMapData_map2 = [
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 2927, 0, 0, 0, 0,
  0, 0, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  0, 0, 0, 0, 0, 0, 0, 2927, 2927, 0, 0, 0, 0, 0, 0, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 0, 0, 0, 0, 0, 0, 0, 2927, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 0, 0, 0, 0, 0, 0,
  2927, 0, 0, 0, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0,
  2927, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 2927, 2927, 0, 0, 0,
  2927, 2927, 0, 0, 2927, 2927, 0, 0, 0, 0, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0,
  2927, 2927, 0, 0, 0, 2927, 2927, 0, 0, 2927, 2927, 0, 0, 0, 0, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 0, 0, 0, 2927, 0, 0, 0,
  0, 0, 0, 2927, 0, 0, 0, 2927, 2927, 0, 0, 0, 2927, 2927, 2927, 2927, 2927,
  2927, 0, 0, 0, 0, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 2927, 2927, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 2927, 0, 0, 0,
  2927, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 0, 0, 2927,
  2927, 0, 0, 0, 2927, 2927, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 0, 0, 2927, 2927, 0, 0, 0, 2927, 2927, 0, 0, 0, 2927,
  0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 2927, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 0, 0, 0, 2927, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 0, 0, 0, 0, 0, 0, 0, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 0, 0, 0, 0, 0, 0,
  2927, 2927, 0, 0, 0, 0, 0, 0, 0, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 0, 0, 0, 0, 0, 0, 2927, 2927, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927, 2927,
  2927, 2927, 2927, 2927, 2927, 2927,
];

// Example assuming map width is 40
const mapWidth = 40;
const mapHeight = 24;
let map2DArray = [];
let towers = [];

function mapto2Darray() {
  for (let i = 0; i < mapHeight; i++) {
    map2DArray.push(tiledMapData.slice(i * mapWidth, (i + 1) * mapWidth));
  }
}

function showVaidPlacements() {
  for (let y = 0; y < map2DArray.length; y++) {
    for (let x = 0; x < map2DArray[y].length; x++) {
      if (map2DArray[y][x] === 2927) {
        ctx.fillStyle = "green"; // Green for placement
        ctx.globalAlpha = 0.2;
        ctx.fillRect(x * 32, y * 32, 32, 32);
      } else if (map2DArray[y][x] === 1) {
        ctx.fillStyle = "red"; // Red for paths
        ctx.globalAlpha = 0.2;
        ctx.fillRect(x * 32, y * 32, 32, 32);
      }
    }
  }
}

function canPlaceTower(x, y) {
  return map2DArray[y][x] === 2927;
}

function placeTower(x, y, type) {
  if (canPlaceTower(x, y)) {
    const towerData = towerTypes[type];
    if (!towerData) {
      console.error("Invalid tower type:", type);
      return;
    }

    // Check if the player has enough currency
    if (playerCurrency >= towerData.cost) {
      let tower;
      if (type === "default") {
        tower = new Tower(x, y, 300, 8, 1000, 50, defaultTowerSpriteInfo, true); // Default tower with specific params
      } else {
        tower = new towerData.class(x, y); // Use class directly for other types
      }
      towers.push(tower);
      playerCurrency -= towerData.cost; // Deduct the cost
      map2DArray[y][x] = 0;

      // Apply weather effects from all active weather bosses to the newly placed tower
      if (activeWeatherBosses.size > 0) {
        // Get any weather boss instance to use its methods
        const anyBoss = Array.from(activeWeatherBosses.values())[0].boss;
        anyBoss.applyWeatherEffectsToTower(tower);
      }
    } else {
      console.log("Not enough currency!");
    }
  } else {
    console.log("Tower placement occupied");
  }
}

let towerPreviewTimer = 0;
let towerPreviewAlpha = 0.5;
let towerPreviewIncreasing = false;

function getTowerRange(towerType) {
  const ranges = {
    default: 300,
    splash: 150,
    xray: 125,
    sniper: 400,
    freezing: 150,
    airdefence: 250,
  };
  return ranges[towerType] || 300; // Default to 300 if not found
}

function drawTowerPreview() {
  // Only draw preview if no tower is selected and hovering over a valid placement tile
  if (selectedTower || hoveredTile.x === -1 || hoveredTile.y === -1) return;

  if (canPlaceTower(hoveredTile.x, hoveredTile.y)) {
    const towerData = towerTypes[selectedTowerType];
    if (!towerData) return;

    // Animate preview alpha for a pulsing effect
    towerPreviewTimer++;
    if (towerPreviewTimer % 10 === 0) {
      if (towerPreviewIncreasing) {
        towerPreviewAlpha += 0.1;
        if (towerPreviewAlpha >= 0.7) {
          towerPreviewIncreasing = false;
        }
      } else {
        towerPreviewAlpha -= 0.1;
        if (towerPreviewAlpha <= 0.3) {
          towerPreviewIncreasing = true;
        }
      }
    }

    // Draw tower range preview
    ctx.beginPath();
    ctx.arc(
      hoveredTile.x * 32 + 16,
      hoveredTile.y * 32 + 16,
      getTowerRange(selectedTowerType),
      0,
      Math.PI * 2
    );
    ctx.fillStyle = `rgba(0, 0, 255, ${towerPreviewAlpha * 0.2})`; // Transparent blue fill
    ctx.fill();
    ctx.strokeStyle = `rgba(0, 0, 255, ${towerPreviewAlpha})`; // Blue border
    ctx.lineWidth = 2;
    ctx.stroke();

    // Save the current context state
    ctx.save();

    // Set global alpha for preview
    ctx.globalAlpha = towerPreviewAlpha;

    // Draw tower preview based on type
    if (selectedTowerType === "default") {
      // Use the default tower sprite sheet
      const { sx, sy, sw, sh, dw, dh, frames, gap } = defaultTowerSpriteInfo;

      // Choose first frame for preview
      ctx.drawImage(
        defaultTowerSpriteSheet,
        sx, // X position on sprite sheet
        sy, // Y position on sprite sheet
        sw, // Source width
        sh, // Source height
        hoveredTile.x * 32, // Destination X
        hoveredTile.y * 32, // Destination Y
        dw, // Destination width
        dh // Destination height
      );
    } else if (selectedTowerType === "splash") {
      // Use the default tower sprite sheet
      const { sx, sy, sw, sh, dw, dh, frames, gap } = splashTowerSpriteInfo;

      // Choose first frame for preview
      ctx.drawImage(
        splashTowerSpriteSheet,
        sx, // X position on sprite sheet
        sy, // Y position on sprite sheet
        sw, // Source width
        sh, // Source height
        hoveredTile.x * 32, // Destination X
        hoveredTile.y * 32, // Destination Y
        dw, // Destination width
        dh // Destination height
      );
    } else if (selectedTowerType === "freezing") {
      // Use the default tower sprite sheet
      const { sx, sy, sw, sh, dw, dh, frames, gap } = iceTowerSpriteInfo;

      // Choose first frame for preview
      ctx.drawImage(
        iceTowerSpriteSheet,
        sx, // X position on sprite sheet
        sy, // Y position on sprite sheet
        sw, // Source width
        sh, // Source height
        hoveredTile.x * 32, // Destination X
        hoveredTile.y * 32, // Destination Y
        dw, // Destination width
        dh // Destination height
      );
    } else if (selectedTowerType === "sniper") {
      // Use the default tower sprite sheet
      const { sx, sy, sw, sh, dw, dh, frames, gap } = sniperTowerSpriteInfo;

      // Choose first frame for preview
      ctx.drawImage(
        sniperTowerSpriteSheet,
        sx, // X position on sprite sheet
        sy, // Y position on sprite sheet
        sw, // Source width
        sh, // Source height
        hoveredTile.x * 32, // Destination X
        hoveredTile.y * 32, // Destination Y
        dw, // Destination width
        dh // Destination height
      );
    } else if (selectedTowerType === "xray") {
      // Use the default tower sprite sheet
      const { sx, sy, sw, sh, dw, dh, frames, gap } = xrayTowerSpriteInfo;

      // Choose first frame for preview
      ctx.drawImage(
        XrayTowerSpriteSheet,
        sx, // X position on sprite sheet
        sy, // Y position on sprite sheet
        sw, // Source width
        sh, // Source height
        hoveredTile.x * 32, // Destination X
        hoveredTile.y * 32, // Destination Y
        dw, // Destination width
        dh // Destination height
      );
    } else if (selectedTowerType === "airdefence") {
      // Use the default tower sprite sheet
      const { sx, sy, sw, sh, dw, dh, frames, gap } = airDefenseTowerSpriteInfo;

      // Choose first frame for preview
      ctx.drawImage(
        airDefenceTowerSpriteSheet,
        sx, // X position on sprite sheet
        sy, // Y position on sprite sheet
        sw, // Source width
        sh, // Source height
        hoveredTile.x * 32, // Destination X
        hoveredTile.y * 32, // Destination Y
        dw, // Destination width
        dh // Destination height
      );
    } else {
      // For other tower types, use a colored rectangle
      ctx.fillStyle = getTowerPreviewColor(selectedTowerType);
      ctx.fillRect(hoveredTile.x * 32, hoveredTile.y * 32, 32 * 2, 32);
    }

    // Restore the context
    ctx.restore();
  }
}

function getTowerPreviewColor(towerType) {
  const colors = {
    splash: "yellow",
    xray: "purple",
    sniper: "Fuchsia",
    freezing: "lightblue",
    airdefence: "ForestGreen",
  };
  return colors[towerType] || "gray";
}
